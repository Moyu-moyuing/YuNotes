import{_ as s,o as a,c as e,N as n}from"./chunks/framework.2b153404.js";const y=JSON.parse('{"title":"进入C++","description":"","frontmatter":{},"headers":[],"relativePath":"articles/05-C++/侯捷C++/侯捷C++面向对象高级设计.md","lastUpdated":1681721444000}'),l={name:"articles/05-C++/侯捷C++/侯捷C++面向对象高级设计.md"},p=n(`<h1 id="进入c" tabindex="-1">进入C++ <a class="header-anchor" href="#进入c" aria-label="Permalink to &quot;进入C++&quot;">​</a></h1><h2 id="c-预处理器和iostream文件" tabindex="-1">C++预处理器和iostream文件 <a class="header-anchor" href="#c-预处理器和iostream文件" aria-label="Permalink to &quot;C++预处理器和iostream文件&quot;">​</a></h2><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">iostream</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">using</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">namespace</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/*#include &lt;iostream&gt;该编译指令导致预处理器</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">将iostream文件加入程序*/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>实际上，#include编译指令将导致iostream文件的内容随源代码文件一起交给编译器，并且 <code>#include &lt;iostream&gt;</code> 指令将被iostream文件的内容替代和源代码一起组成一个复合文件</p><h2 id="头文件" tabindex="-1">头文件 <a class="header-anchor" href="#头文件" aria-label="Permalink to &quot;头文件&quot;">​</a></h2><p>像iostream这样的文件叫做包含文件，由于它们被包含在其他文件中，也叫头文件——由于他们被包含在文件起始处。头文件使用扩展名h，C++新式风格没有h扩展名。</p><p>头文件书写有自己的规范，对于complex.h</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">#idndef _COMPLEX_</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#define</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">_COMPLEX_</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//头文件内容</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#endif</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="名称空间" tabindex="-1">名称空间 <a class="header-anchor" href="#名称空间" aria-label="Permalink to &quot;名称空间&quot;">​</a></h2><p>如果使用iostream而非iostream.h，则应该使用下面的名称空间编译指令 <code>using namespace std;</code> 。这是using编译指令。名称空间支持是C++一大特性，这里存在一个问题：对于两个已经封装好的C++文件，它们都包含同一函数名的函数，当使用此函数时，编译器其实不知道具体指的是哪个版本的函数。名称空间使得文件内容封装在一个名称空间的单元中，这样就可以用名称空间的名称来指出具体某个文件的具体函数。</p><p>示例：</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Bob</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">sayHi</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#FFCB6B;">John</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">sayHi</span><span style="color:#89DDFF;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>按照此方式来讲，类、函数、变量就是C++编译器的标准组件，它们现在都存放在名称空间std中。这意味着iostream中定义的用于输出的cout变量实际是 <code>std::cout</code>，而endl实际是 <code>std::endl</code>。而当使用using编译指令后，就可以使用std名称空间中定义的名称而不用加 <code>std::</code>前缀。</p><p>四种访问名称空间std的方法：</p><ul><li>将 <code>using namespace std;</code>放在函数定义之前，让文件中所有函数能够使用名称空间std中所有的元素</li><li>将 <code>using namespace std;</code>放在特定函数定义中，让该函数能够使用名称空间std中所有元素</li><li>在特定的函数中使用类似 <code>using std::cout;</code>这种编译指令，而不是使用 <code>using namespace std; </code>，让该函数能够使用特定的元素如 <code>cout</code></li><li>完全不使用编译指令 <code>using</code>，而在需要使用名称空间std中元素时使用前缀 <code>std::</code>。</li></ul><h2 id="变量名称规则" tabindex="-1">变量名称规则 <a class="header-anchor" href="#变量名称规则" aria-label="Permalink to &quot;变量名称规则&quot;">​</a></h2><p>C++提倡使用一定含义的变量名，以下是命名规则：</p><ul><li>名称中只能使用字母字符、数字和下划线；</li><li>名称的第一个字符不能是数字；</li><li>区分大小写；</li><li>不能用关键字作为名称；</li><li>以两个下划线开头（如：<code>__xxxx</code>或者 <code>_大写字母xxx</code>）或者以下划线和大写字母打头的名称将被保留（留与编译器或其使用资源使用），以一个下划线开头的名称将被保留（用作全局标识符）。</li></ul><h2 id="符号常量" tabindex="-1">符号常量 <a class="header-anchor" href="#符号常量" aria-label="Permalink to &quot;符号常量&quot;">​</a></h2><p>#define编译指令工作方式与文本编辑器</p><h1 id="基于对象" tabindex="-1">基于对象 <a class="header-anchor" href="#基于对象" aria-label="Permalink to &quot;基于对象&quot;">​</a></h1><p>构造函数</p><h2 id="内联函数" tabindex="-1">内联函数 <a class="header-anchor" href="#内联函数" aria-label="Permalink to &quot;内联函数&quot;">​</a></h2><p>内联函数是C++为了提高程序运行速度所做的一项改进，一般函数和内联函数之间主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。通常，在执行一般函数的调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，然后跳到标记函数起点的内存单元，执行函数后，再跳回地址被保存的指令处（即原位置），程序将会来回跳跃地址，这需要一定的时间开销。而C++内联函数的编译代码与其他代码内联起来，编译器将使用相应函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码再跳回，因此内联函数运行速度更快，但需要更多内存。</p><p>如果要使用内联函数，必须：</p><ul><li>在函数声明前加上inline</li><li>或在函数定义前加上inline</li></ul><p>注意：内联函数不能递归；函数过大或者函数调用了自己，则编译器不会将其作为内联函数</p><h2 id="内联与宏" tabindex="-1">内联与宏 <a class="header-anchor" href="#内联与宏" aria-label="Permalink to &quot;内联与宏&quot;">​</a></h2><p>inline是C++新特性，C使用预处理语句#define来提供宏——内联代码的原始实现</p><p>示例：</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">#define</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ADD</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">X</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> X+X</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这并不是通过传参来实现，而是通过文本替换，X是参数的符号标记</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">sum_a</span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;">ADD</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span><span style="color:#676E95;font-style:italic;">//等价于sum_a=3+3;</span></span>
<span class="line"><span style="color:#A6ACCD;">sum_b</span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;">ADD</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span><span style="color:#676E95;font-style:italic;">//等价于sum_b=3-2+3-2;</span></span>
<span class="line"><span style="color:#A6ACCD;">sum_c</span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;">ADD</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">--);</span><span style="color:#676E95;font-style:italic;">//等价于sum_c=c--+c--;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上述代码当然可以通过添加适当的括号改进类似于 <code>#define ADD(X) ((X)+(X))</code> ，但是因为宏并不能按值传递，则 <code>ADD(c--)</code>中的c变量依然会被调用两次递减两次，这和预期并不同，因此我们可以考虑将宏函数转换成内联函数使用。</p><h2 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h2><h1 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to &quot;面向对象&quot;">​</a></h1>`,36),o=[p];function t(c,i,r,d,u,h){return a(),e("div",null,o)}const b=s(l,[["render",t]]);export{y as __pageData,b as default};
