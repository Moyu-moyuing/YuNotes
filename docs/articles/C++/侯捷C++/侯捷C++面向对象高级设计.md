# 进入C++

## C++预处理器和iostream文件

```cpp
#include <iostream>
using namespace std;
/*#include <iostream>该编译指令导致预处理器
将iostream文件加入程序*/
```

实际上，#include编译指令将导致iostream文件的内容随源代码文件一起交给编译器，并且 `#include <iostream>` 指令将被iostream文件的内容替代和源代码一起组成一个复合文件

## 头文件

像iostream这样的文件叫做包含文件，由于它们被包含在其他文件中，也叫头文件——由于他们被包含在文件起始处。头文件使用扩展名h，C++新式风格没有h扩展名。

头文件书写有自己的规范，对于complex.h

```cpp
#idndef _COMPLEX_
#define _COMPLEX_
//头文件内容
#endif
```

## 名称空间

如果使用iostream而非iostream.h，则应该使用下面的名称空间编译指令 `using namespace std;` 。这是using编译指令。名称空间支持是C++一大特性，这里存在一个问题：对于两个已经封装好的C++文件，它们都包含同一函数名的函数，当使用此函数时，编译器其实不知道具体指的是哪个版本的函数。名称空间使得文件内容封装在一个名称空间的单元中，这样就可以用名称空间的名称来指出具体某个文件的具体函数。

示例：

```cpp
Bob::sayHi();
John::sayHi();
```

按照此方式来讲，类、函数、变量就是C++编译器的标准组件，它们现在都存放在名称空间std中。这意味着iostream中定义的用于输出的cout变量实际是 `std::cout`，而endl实际是 `std::endl`。而当使用using编译指令后，就可以使用std名称空间中定义的名称而不用加 `std::`前缀。

四种访问名称空间std的方法：

* 将 `using namespace std;`放在函数定义之前，让文件中所有函数能够使用名称空间std中所有的元素
* 将 `using namespace std;`放在特定函数定义中，让该函数能够使用名称空间std中所有元素
* 在特定的函数中使用类似 `using std::cout;`这种编译指令，而不是使用 `using namespace std; `，让该函数能够使用特定的元素如 `cout`
* 完全不使用编译指令 `using`，而在需要使用名称空间std中元素时使用前缀 `std::`。

## 变量名称规则

C++提倡使用一定含义的变量名，以下是命名规则：

* 名称中只能使用字母字符、数字和下划线；
* 名称的第一个字符不能是数字；
* 区分大小写；
* 不能用关键字作为名称；
* 以两个下划线开头（如：`__xxxx`或者 `_大写字母xxx`）或者以下划线和大写字母打头的名称将被保留（留与编译器或其使用资源使用），以一个下划线开头的名称将被保留（用作全局标识符）。

## 符号常量

#define编译指令工作方式与文本编辑器

# 基于对象

构造函数

## 内联函数

内联函数是C++为了提高程序运行速度所做的一项改进，一般函数和内联函数之间主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。通常，在执行一般函数的调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，然后跳到标记函数起点的内存单元，执行函数后，再跳回地址被保存的指令处（即原位置），程序将会来回跳跃地址，这需要一定的时间开销。而C++内联函数的编译代码与其他代码内联起来，编译器将使用相应函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码再跳回，因此内联函数运行速度更快，但需要更多内存。

如果要使用内联函数，必须：

* 在函数声明前加上inline
* 或在函数定义前加上inline

注意：内联函数不能递归；函数过大或者函数调用了自己，则编译器不会将其作为内联函数

## 内联与宏

inline是C++新特性，C使用预处理语句#define来提供宏——内联代码的原始实现

示例：

```cpp
#define ADD(X) X+X
```

这并不是通过传参来实现，而是通过文本替换，X是参数的符号标记

```cpp
sum_a=ADD(3);//等价于sum_a=3+3;
sum_b=ADD(3-2);//等价于sum_b=3-2+3-2;
sum_c=ADD(c--);//等价于sum_c=c--+c--;
```

上述代码当然可以通过添加适当的括号改进类似于 `#define ADD(X) ((X)+(X))` ，但是因为宏并不能按值传递，则 `ADD(c--)`中的c变量依然会被调用两次递减两次，这和预期并不同，因此我们可以考虑将宏函数转换成内联函数使用。

## 构造函数

# 面向对象
